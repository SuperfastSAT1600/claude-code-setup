# 종합 Claude Code 워크플로우 가이드

Claude Code를 활용하여 생산성을 극대화하는 완전한 가이드입니다.

**이 문서는 무엇인가요?** 이 문서는 Claude Code를 효과적으로 사용하기 위한 단일 진실 공급원(Single Source of Truth)입니다. Boris Cherny와 Everything-Claude-Code의 모범 사례를 결합하고, 실제 운영 환경에서 검증된 패턴, 보안 우선 워크플로우, 팀 협업 전략으로 강화되었습니다.

**누구를 위한 것인가요?** 개인이든 팀이든, 처음 시작하는 개발자부터 파워 유저까지 Claude Code를 도입하는 모든 개발자를 위한 것입니다.

**빠른 내비게이션:**
- 📋 **[.claude/agents/INDEX.md](.claude/agents/INDEX.md)** - 에이전트 디렉토리 및 사용 가이드
- 📚 **[.claude/skills/INDEX.md](.claude/skills/INDEX.md)** - 스킬 디렉토리 및 선택 가이드
- ⚡ **[README.md](README.md)** - 프로젝트 개요

---

## 목차

1. [철학과 핵심 개념](#1-철학과-핵심-개념)
2. [빠른 의사결정 트리](#2-빠른-의사결정-트리)
3. [완전한 워크플로우 패턴](#3-완전한-워크플로우-패턴)
4. [에이전트 오케스트레이션](#4-에이전트-오케스트레이션)
5. [MCP 서버 통합](#5-mcp-서버-통합)
6. [성능 및 최적화](#6-성능-및-최적화)
7. [커스터마이제이션 로드맵](#7-커스터마이제이션-로드맵)
8. [팀 협업](#8-팀-협업)
9. [문제 해결](#9-문제-해결)
10. [고급 주제](#10-고급-주제)

---

## 1. 철학과 핵심 개념

### 1.1 강화된 철학

이 템플릿은 세 가지 강력한 접근 방식을 통합합니다:

**Boris Cherny로부터:**
- **복합적 엔지니어링**: CLAUDE.md는 모든 실수와 함께 성장하며 팀 지식 기반을 만듭니다
- **검증 루프**: 지속적인 검증을 통해 품질을 2-3배 향상시킵니다
- **계획 모드 우선**: 구현 전에 항상 복잡한 작업을 계획합니다
- **병렬 세션**: 여러 Claude 세션을 동시에 실행합니다
- **모델 선택**: 작업 복잡도에 맞는 모델을 선택합니다 (Haiku/Sonnet/Opus)

**Everything-Claude-Code로부터:**
- **가드레일로서의 규칙**: 항상 활성화된 품질 강제로 실수를 자동으로 방지합니다
- **지식으로서의 스킬**: 재사용 가능한 패턴이 반복을 줄이고 일관성을 보장합니다
- **컨텍스트 관리**: 200k → 70k 성능 저하 문제에 대한 실전 테스트된 인식
- **에이전트 위임**: 격리된 컨텍스트를 가진 전문 에이전트에게 전문 작업을 위임합니다
- **커뮤니티 확장성**: 도메인별 지식을 위한 플러그인 생태계

**우리만의 고유한 통합:**
- **보안 우선**: 전용 보안 규칙 + 에이전트 + 명령어로 보안을 자동화합니다
- **다중 환경**: 개발/운영 구성으로 프로덕션 안전성을 보장합니다
- **점진적 도입**: 몇 주 안에 빠른 시작부터 완전한 파워 유저까지
- **팀 준비**: 공유 CLAUDE.md를 통한 협업 개발을 위해 설계되었습니다
- **실전 검증**: 실제 컨텍스트 임계값 및 성능 패턴

### 1.2 핵심 원칙

**원칙 1: 메인 에이전트가 먼저 코딩합니다**
메인 에이전트는 표준 개발 작업(CRUD, 간단한 기능, 버그 수정)을 직접 처리합니다. 복잡한 도메인(인증, 데이터베이스 스키마, 보안, 성능)에만 전문가에게 위임하세요.

**원칙 2: 스펙 기반 TDD**
Spec-Driven TDD가 기본 워크플로우입니다. 계획 모드 진입 → 스펙 작성 → `/tdd` 또는 `/parallel-tdd` → `/checkpoint` → `/commit-push-pr`. 스펙이 `.claude/plans/`에 작성되기 전까지 코딩 도구는 차단됩니다.

**원칙 3: 지속적으로 검증하세요**
모든 커밋 전에 `/checkpoint`를 실행하세요. 타입 검사, 린트, 테스트, 빌드, 보안을 통합 검증합니다.

**원칙 4: 전문가에게 위임하세요**
도메인 전문성이 필요한 경우 전문 에이전트를 사용하세요 (auth-specialist, code-reviewer, frontend-specialist 등). 에이전트는 격리된 컨텍스트와 집중된 전문성을 가지고 있습니다.

**원칙 5: 지식을 축적하세요**
모든 실수 후에 CLAUDE.md를 업데이트하세요. 팀의 공유 지식은 프로젝트와 함께 성장합니다.

**원칙 6: 컨텍스트를 관리하세요**
컨텍스트 사용량을 80k 토큰 이하로 유지하세요. 사용하지 않는 MCP를 비활성화하고, 무거운 작업을 에이전트에 위임하며, 필요할 때 새로운 세션을 시작하세요.

### 1.3 시스템 개요

**하이브리드 에이전트 모델** - 메인 에이전트가 코딩하고, 전문가가 전문성을 제공
- 메인 에이전트가 70%의 작업을 직접 처리 (CRUD, 간단한 기능, 버그 수정)
- 복잡한 도메인을 위한 10개의 전문 에이전트 사용 가능
- 효율적인 워크플로우: 먼저 코딩하고, 전문 지식이 필요할 때 위임

**명령어(Commands)** - 사용자가 트리거하는 워크플로우
- `/plan`, `/tdd`, `/parallel-tdd`, `/checkpoint`, `/commit-push-pr` 같은 슬래시 명령어
- 하나의 명령어로 전체 워크플로우 실행
- **25개의 명령어 사용 가능**: 워크플로우 오케스트레이션, 개발, 품질, 유지보수를 다룸

**에이전트(Agents)** - 전문화된 자율 작업자 (총 10개)
- architect, code-reviewer, test-writer, backend-specialist, auth-specialist
- devops-specialist, frontend-specialist, realtime-specialist, mobile-specialist, doc-updater
- 에이전트는 격리된 컨텍스트와 특정 도구를 가집니다
- 전체 목록은 `.claude/agents/INDEX.md` 참조

**규칙(Rules)** - 항상 활성화된 가드레일
- 핵심 가이드라인: `essential-rules.md` (보안, 코딩 스타일, TypeScript, 테스트, 에러 처리, API 디자인)
- 워크플로우 규칙: `orchestration.md` (하이브리드 모델 위임 원칙)
- 모든 상호작용에서 자동으로 강제됩니다

**스킬(Skills)** - 재사용 가능한 지식 패턴 (총 21개)
- 메인 에이전트와 전문 에이전트가 참조합니다
- 반복을 줄이고 일관성을 보장합니다
- 카테고리: 프레임워크 패턴 (React, Next.js, Node.js), API 디자인 (REST, GraphQL, WebSocket), 개발 관행 (TDD, 인증, 데이터베이스, 문서화), 프로젝트 관리 (가이드라인, 사용자 의도, 프롬프트 엔지니어링)

**워크플로우(Workflows)** - 오케스트레이션된 시퀀스
- 다단계 자동화 워크플로우
- `.claude/workflows/` 디렉토리 참조

**체크리스트(Checklists)** - 검토 표준
- 품질 게이트를 위한 포괄적인 체크리스트
- **12개의 체크리스트**: PR 검토, 보안 감사, 성능 감사, 접근성 감사, 출시 전, 온보딩, 배포, 데이터베이스 마이그레이션, 의존성 감사, 핫픽스, 빌드 오류, E2E 테스트

**템플릿(Templates)** - 코드 스캐폴딩
- 일반적인 패턴을 위한 재사용 가능한 코드 템플릿
- 스펙 템플릿: `spec.md.template`, `spec-api.md.template`, `spec-bugfix.md.template`, `spec-ui.md.template`

**스크립트(Scripts)** - 자동화 헬퍼
- 일반적인 자동화 작업을 위한 셸 스크립트
- `.claude/scripts/` 디렉토리 참조

**MCP 서버** - 외부 도구 통합
- 필요한 것만 활성화하세요 (filesystem, github, database, deployment, docker, playwright 등)
- 최적 성능을 위해 활성화된 개수를 10개 미만으로 유지하세요

---

## 2. 빠른 의사결정 트리

### 2.1 "내가 해야 할 일은..." 의사결정 트리

```
내가 해야 할 일은...

├─ 새로운 기능 추가
│  ├─ 간단함 (<3개 파일) → 바로 구현
│  ├─ 중간 (3-10개 파일) → /plan 먼저, 스펙 작성, 그다음 /tdd
│  └─ 복잡함 (>10개 파일) → /plan + architect 에이전트, 그다음 /parallel-tdd

├─ 버그 수정
│  ├─ 알려진 수정 → /quick-fix로 바로 구현
│  ├─ 조사 필요 → 구현, 그다음 /checkpoint
│  └─ 복잡한 근본 원인 → 플랜 모드 + 조사

├─ 코드 리팩토링
│  ├─ 작은 리팩토링 (<5개 파일) → 바로 구현
│  ├─ 모듈 리팩토링 → /refactor-clean 명령어
│  └─ 아키텍처 변경 → 플랜 모드 + architect 에이전트

├─ 오류 처리
│  ├─ 빌드 오류 → /build-fix 명령어
│  ├─ 테스트 실패 → /checkpoint (자동 수정)
│  └─ 타입 오류 → /type-check 명령어

├─ 테스트 작성
│  ├─ 단위 테스트 → /tdd (TDD 접근 방식)
│  ├─ E2E 테스트 → /e2e 명령어
│  ├─ 커버리지 확인 → /test-coverage 명령어
│  └─ 테스트 단계별 확장 → /test-ladder 명령어

└─ 배포/릴리스
   ├─ 일반 릴리스 → /commit-push-pr
   ├─ 중요 릴리스 → /checkpoint + /commit-push-pr
   └─ 핫픽스 → 필수 검증을 통한 빠른 트랙
```

### 2.2 명령어 선택 매트릭스

| 상황 | 명령어 | 사용 이유 |
|------|--------|-----------|
| 기능 계획 | `/plan` | 스펙 기반 계획 수립 |
| TDD 개발 | `/tdd` | 단일 에이전트 스펙 기반 TDD |
| 병렬 TDD | `/parallel-tdd` | 다중 에이전트 워크트리 기반 TDD |
| 검증 게이트 | `/checkpoint` | 타입, 린트, 테스트, 빌드, 보안 통합 검증 |
| PR 생성 | `/commit-push-pr` | 전체 워크플로우 자동화 |
| 빠른 수정 | `/quick-fix` | 간단한 버그 수정 |
| 코드 리뷰 | `/review` | 코드 품질 리뷰 |
| 빌드 수정 | `/build-fix` | 자동화된 체계적 오류 해결 |
| 타입 검사 | `/type-check` | TypeScript 타입 오류 수정 |
| 커버리지 확인 | `/test-coverage` | 격차 식별 및 우선순위 지정 |
| 테스트 확장 | `/test-ladder` | 단계별 테스트 확장 |
| 컴포넌트 생성 | `/new-component` | React 컴포넌트 스캐폴딩 |
| 마이그레이션 | `/create-migration` | 데이터베이스 마이그레이션 생성 |
| E2E 테스트 | `/e2e` | 사용자 워크플로우 검증 |
| 문서 업데이트 | `/update-docs` | 문서를 동기화 상태로 유지 |
| 리팩토링 | `/refactor-clean` | 체계적 정리 및 현대화 |
| 전체 기능 | `/full-feature` | 종합 기능 개발 워크플로우 |
| 탐색 | `/spike` | 기술 탐색 및 프로토타이핑 |
| 시스템 점검 | `/health-check` | 종합적인 시스템 감사 |
| 세션 보고 | `/session-report` | 세션 요약 생성 |
| 시스템 업데이트 | `/update-system` | 시스템 파일 업데이트 |
| 요구사항 커버리지 | `/req-coverage` | REQ 커버리지 분석 |
| 요구사항 상태 | `/req-status` | REQ 상태 확인 |
| 스텁 생성 | `/generate-stubs` | 테스트 스텁 자동 생성 |
| 로컬 서버 | `/open-localhost` | 개발 서버를 브라우저에서 열기 |

### 2.3 에이전트 선택 매트릭스

| 작업 유형 | 에이전트 | 사용 시기 |
|-----------|---------|-----------|
| 아키텍처 | `architect` | 시스템 설계, 계획, 트레이드오프 |
| 코드 리뷰 | `code-reviewer` | PR 리뷰, 보안, TypeScript, 기술 부채 |
| 테스트 | `test-writer` | TDD, 단위/통합/E2E/부하 테스트 |
| 백엔드 | `backend-specialist` | REST API, DB 스키마, 마이그레이션 |
| 인증 | `auth-specialist` | OAuth, JWT, MFA, 세션 |
| DevOps | `devops-specialist` | CI/CD, Docker, IaC, 모니터링, 빌드 오류, 의존성 |
| 프론트엔드 | `frontend-specialist` | 접근성, 국제화, Core Web Vitals |
| 실시간 | `realtime-specialist` | WebSocket, GraphQL, AI/ML |
| 모바일 | `mobile-specialist` | React Native, Flutter |
| 문서화 | `doc-updater` | 코드와 문서 동기화 |

### 2.4 모델 선택 가이드

| 작업 복잡도 | 모델 | 비용 | 속도 | 최적 사용처 |
|-------------|------|------|------|------------|
| 간단함 | Haiku | $ | 빠름 | 포맷팅, 간단한 수정, 빠른 검사 |
| 표준 | Sonnet | $$ | 중간 | 대부분의 개발, 리팩토링, 테스트 (기본값) |
| 복잡함 | Opus | $$$ | 느림 | 아키텍처, 중요한 결정, 보안 |

**기본 구성**: Sonnet (대부분의 작업에 균형잡힘)

**Haiku로 전환해야 할 때**:
- Prettier/ESLint로 코드 포맷팅
- 간단한 한 줄 수정
- 테스트 반복 실행
- 빠른 리팩토링 (<10줄)

**Opus로 전환해야 할 때**:
- 시스템 아키텍처 설계
- 보안이 중요한 코드
- 프로덕션 인시던트
- 복잡한 알고리즘
- 대규모 리팩토링

---

## 3. 완전한 워크플로우 패턴

### 3.1 스펙 기반 TDD (기본 워크플로우)

**1단계: 계획 모드 진입**

```
계획 모드에서 접근 방식을 사용자와 논의합니다.
[Shift+Tab 두 번] 또는 /plan

→ 요구사항 분석
→ 구현 전략 수립
→ 사용자 승인 획득
```

**2단계: 스펙 작성**

```
.claude/plans/[feature].md에 스펙을 작성합니다
→ .claude/templates/spec.md.template 사용
→ 각 요구사항에 REQ-XXX ID 부여
→ 각 REQ에 (TEST)/(BROWSER)/(MANUAL) 검증 태그 추가
→ 스펙 작성 시 audit-spec.sh가 자동으로 검증합니다
→ 스펙이 검증을 통과해야 코딩 도구가 활성화됩니다
```

**3단계: TDD 구현**

옵션 A - 단일 에이전트 TDD:
```
/tdd
→ Red-Green-Refactor 사이클을 따릅니다
→ 먼저 실패하는 테스트 작성
→ 통과하는 최소한의 코드 구현
→ 테스트 안전망과 함께 리팩토링
```

옵션 B - 병렬 TDD (여러 REQ가 있는 경우):
```
/parallel-tdd
→ 에이전트 팀이 워크트리에서 병렬 작업
→ 각 에이전트가 별도의 REQ를 구현
→ 공유 태스크 리스트로 자체 조정
```

**4단계: 통합 검증 게이트**

```
/checkpoint
→ 타입 검사 (TypeScript)
→ 린트 (ESLint)
→ 테스트 실행
→ 빌드 검증
→ 보안 검사
→ 모두 통과할 때까지 문제 자동 수정
```

**5단계: 릴리스**

```
/commit-push-pr
→ Conventional Commits 형식으로 커밋합니다
→ 원격 브랜치에 푸시합니다
→ 다음 내용으로 풀 리퀘스트를 생성합니다:
   - 변경 사항 요약
   - 테스트 계획 체크리스트
   - Claude Code로 생성됨 표시
```

### 3.2 실제 예제: 사용자 인증 추가

**JWT 토큰을 사용한 인증 구현의 완전한 연습:**

```markdown
사용자: "JWT 토큰을 사용한 이메일/비밀번호 인증을 추가해야 합니다"

Claude (플랜 모드): [상세한 계획 생성]
─────────────────────────────────────────────────────────
구현 계획: 사용자 인증

1. 데이터베이스 스키마
   - users 테이블 생성 (id, email, password_hash, created_at)
   - email에 고유 제약 조건 추가
   - 마이그레이션 파일 생성

2. API 라우트
   - POST /api/auth/register (계정 생성)
   - POST /api/auth/login (JWT 토큰 획득)
   - GET /api/auth/me (현재 사용자 가져오기)
   - Zod 스키마로 유효성 검사 추가

3. 인증 미들웨어
   - JWT 토큰 검증
   - 요청에 사용자 첨부
   - 토큰 만료 처리

4. 프론트엔드 컴포넌트
   - LoginForm 컴포넌트 (이메일 + 비밀번호)
   - RegisterForm 컴포넌트 (이메일 + 비밀번호 + 확인)
   - 보호된 라우트 래퍼

5. 보안 고려사항
   - 비밀번호 해싱에 bcrypt 사용 (10 라운드)
   - JWT를 httpOnly 쿠키에 저장
   - 짧은 만료 시간 (15분 액세스, 7일 갱신)
   - 로그인 엔드포인트에 속도 제한 추가
   - 상태 변경 요청을 위한 CSRF 보호

설치할 의존성:
- jsonwebtoken
- bcrypt
- zod (유효성 검사용)
─────────────────────────────────────────────────────────

사용자: "승인합니다, 진행하세요"

Claude: [스펙을 .claude/plans/user-auth.md에 작성]
→ REQ-001: 사용자 등록 (TEST)
→ REQ-002: 사용자 로그인 (TEST)
→ REQ-003: JWT 미들웨어 (TEST)
→ REQ-004: 프론트엔드 폼 (BROWSER)
→ REQ-005: 보안 강화 (TEST)

메인 에이전트: "복잡한 인증 작업입니다, auth-specialist에게 위임합니다"

auth-specialist 에이전트: [계획에 따라 구현]
→ 데이터베이스 마이그레이션 생성
→ 유효성 검사와 함께 API 라우트 구현
→ JWT 기반 인증 미들웨어 생성
→ 프론트엔드 컴포넌트 구축
→ 적절한 에러 처리 및 속도 제한 추가

사용자: "/checkpoint"

Claude (/checkpoint 명령어): [통합 검증]
─────────────────────────────────────────────────────────
검증 결과:

✅ 타입 검사 통과
✅ ESLint 통과
✅ 모든 테스트 통과 (15개)
✅ 빌드 성공
✅ 보안 검사 통과:
   - bcrypt로 비밀번호 해싱 (10 라운드)
   - JWT가 httpOnly 쿠키에 저장됨
   - Zod로 입력 유효성 검사
   - 하드코딩된 시크릿 없음 (env 변수 사용)
   - SQL 인젝션 방지 (매개변수화된 쿼리)
─────────────────────────────────────────────────────────

사용자: "/commit-push-pr"

Claude: [커밋 및 PR 생성]
─────────────────────────────────────────────────────────
✅ 커밋 생성됨:
   feat: add user authentication with JWT tokens

✅ 푸시됨: feature/user-authentication

✅ 풀 리퀘스트 생성됨: #42
   제목: feat: add user authentication with JWT tokens

   ## 요약
   - 이메일/비밀번호 인증 구현
   - JWT 토큰 기반 세션 관리
   - 속도 제한 및 CSRF 보호
   - 종합적인 테스트 커버리지

   ## 테스트 계획
   - [x] 유효한 데이터로 사용자 등록
   - [x] 이메일/비밀번호 유효성 검사
   - [x] 로그인/로그아웃 플로우
   - [x] 보호된 라우트 접근 제어
   - [x] 보안 감사 통과
   - [x] 모든 테스트 통과
   - [x] 빌드 성공

   🤖 [Claude Code](https://claude.com/claude-code)로 생성됨
─────────────────────────────────────────────────────────

총 소요 시간: 약 30분
품질: 보안이 내장된 프로덕션 준비 완료
커버리지: 95% 테스트 커버리지, 모든 엣지 케이스 처리됨
```

### 3.3 버그 수정 워크플로우

**간단한 버그** (알려진 수정):

```
1. 문제 식별
2. /quick-fix로 수정 구현
3. /checkpoint (회귀 없음 확인)
4. /commit-push-pr
```

**복잡한 버그** (조사 필요):

```
1. 메인 에이전트가 버그 재현
2. 메인 에이전트가 근본 원인 조사
3. 간단한 수정: 메인 에이전트가 직접 구현
   복잡한 수정: [Shift+Tab 두 번] 수정 계획 생성
4. 메인 에이전트가 수정 구현
5. /checkpoint
6. /commit-push-pr
```

**예제 - 타임존 버그 수정:**

```
사용자: "사용자가 다른 타임존에 있을 때 날짜 선택기가 잘못된 날짜를 표시합니다"

메인 에이전트: [직접 조사]
→ DatePicker.tsx 컴포넌트 읽기
→ 문제 발견: UTC 대신 new Date() 사용
→ 근본 원인: 사용자 타임존 설정 무시

메인 에이전트: "간단한 수정입니다, 직접 구현합니다"
→ 데이터베이스에 날짜를 UTC로 저장
→ 프론트엔드에서 사용자 타임존으로 변환
→ 날짜 선택기가 사용자 타임존을 사용하도록 업데이트
→ 여러 타임존에 대한 테스트 추가 (US/Pacific, US/Eastern, Europe/London, Asia/Tokyo)
→ 3개 파일에서 수정 구현: DatePicker.tsx, formatDate.ts, date.test.ts

/checkpoint
→ 모든 테스트 통과 ✅

/commit-push-pr
→ fix: respect user timezone in date picker
```

### 3.4 레거시 코드 리팩토링

**작은 리팩토링 (<5개 파일)**:
```
1단계: 테스트가 있는지 확인
/test-coverage [경로]
→ 커버리지 <80%인 경우, 메인 에이전트가 먼저 테스트를 작성합니다
→ 테스트는 리팩토링 중 안전망입니다

2단계: 메인 에이전트가 직접 리팩토링
→ 함수 추출, 명확한 이름으로 변경
→ 중복 제거, 조건문 단순화
→ 각 변경 후 테스트 실행

3단계: 손상 없음 확인
/checkpoint
→ 모든 테스트가 여전히 통과

4단계: 커밋
/commit-push-pr
→ refactor: simplify [모듈 이름]
```

**큰 리팩토링 (>5개 파일)**:
```
1단계: 테스트가 있는지 확인
/test-coverage [경로]
→ 커버리지 <80%인 경우, 먼저 테스트를 작성합니다

2단계: 리팩토링 전략 생성 (선택사항)
/plan "리팩토링 [모듈 이름]"
→ architect 에이전트가 전략을 생성합니다
→ 점진적 단계를 계획합니다

3단계: 코드 리팩토링
/refactor-clean
→ 체계적인 현대화
→ 죽은 코드 제거
→ 최신 패턴으로 업데이트

4단계: 손상 없음 확인
/checkpoint
→ 모든 테스트가 여전히 통과

5단계: 코드 리뷰
/review
→ 리팩토링 품질 확인

6단계: 커밋
/commit-push-pr
→ refactor: modernize [모듈 이름]
```

### 3.5 프로덕션 인시던트 대응

```
1단계: 인시던트 이해
→ 오류 로그 검토
→ 영향 및 심각도 식별
→ 가능하면 재현

2단계: 대응 계획 생성
[Shift+Tab 두 번]
→ architect 에이전트에게 위임하여 인시던트 대응 계획 생성
→ 영향별로 수정 우선순위 지정
→ 빠른 해결책 대 장기 수정 식별

3단계: 핫픽스 구현
→ 중요한 문제의 경우, 필요하면 일반 워크플로우 우회
→ 먼저 출혈 중단에 집중

4단계: 수정 확인
/checkpoint
→ 타입, 테스트, 빌드 모두 통과하는지 확인

5단계: 배포
/commit-push-pr
→ 커밋에 "hotfix:" 접두사 사용
→ 즉시 프로덕션에 배포

6단계: 사후 검토
→ 배운 교훈으로 CLAUDE.md 업데이트
→ 무엇이 잘못되었는지 문서화
→ 예방 조치 추가
→ 모니터링/알림 개선
```

### 3.6 코드 리뷰 및 릴리스 전 워크플로우

**모든 PR 전** (필수):

```
1. /review
   → 코드 품질 리뷰
   → 모범 사례 확인
   → 패턴 준수

2. /test-coverage
   → 적절한 테스트 확인
   → 최소 80% 커버리지
   → 중요 경로 테스트됨

3. /checkpoint
   → 타입 검사, 린트, 테스트, 빌드, 보안 통합 검증
   → 모든 항목 통과

그다음:
4. /commit-push-pr
   → 풀 리퀘스트 생성
   → 테스트 계획 포함
   → 리뷰어 태그
```

---

## 4. 에이전트 오케스트레이션

### 4.1 하이브리드 에이전트 모델

**핵심 철학**: 메인 에이전트는 표준 작업을 직접 코딩하고, 전문성이 필요한 경우 전문가에게 위임합니다.

**메인 에이전트가 직접 처리하는 작업**:
- 표준 CRUD 작업
- 간단한 버그 수정 (< 3개 파일)
- 기본 리팩토링
- 문서 업데이트
- 간단한 기능 구현 (컴포넌트, 라우트, 서비스)
- Git 작업 (커밋, 푸시, PR)
- 템플릿 사용 및 패턴 따르기

**전문가에게 위임해야 하는 경우**:
- 복잡한 아키텍처 필요 → `architect`
- 인증 도메인 → `auth-specialist`
- 백엔드/API/DB → `backend-specialist`
- 보안 및 코드 품질 리뷰 → `code-reviewer`
- 테스트 전략 → `test-writer`
- 프론트엔드 최적화 → `frontend-specialist`
- 실시간/WebSocket/GraphQL → `realtime-specialist`
- 모바일 앱 → `mobile-specialist`
- 운영/CI/CD/Docker → `devops-specialist`
- 문서화 → `doc-updater`

### 4.2 순차적 패턴

**패턴 1: 간단한 기능 (메인 에이전트만 사용)**

```
1. 메인 에이전트가 요구사항 분석
   → 컨텍스트 이해
   → 변경할 파일 식별

2. 메인 에이전트가 직접 구현
   → 코드 + 테스트 작성
   → 프로젝트 패턴 따르기
   → 템플릿 사용

3. 메인 에이전트가 자체 검증
   → /checkpoint 실행
   → 선택사항: 복잡한 경우 code-reviewer에 위임

4. 메인 에이전트가 커밋
   → /commit-push-pr
```

**패턴 2: 복잡한 기능 (전문가 사용)**

```
1. 선택사항: architect 에이전트에 위임 (복잡한 경우)
   → 상세한 구현 계획 생성
   → 의존성 식별
   → 테스트 전략 제안

2. 메인 에이전트 OR 전문가가 구현
   → 표준 작업: 메인 에이전트가 직접 코딩
   → 특수 작업: 도메인 전문가에게 위임
   → 계획을 단계별로 따름

3. code-reviewer 에이전트에 위임 (선택사항)
   → 코드 품질 리뷰
   → 보안 확인
   → 기술 부채 식별

4. /checkpoint
   → 통합 검증
```

**패턴 3: 리팩토링 → 테스트 → 문서화**

```
1. 작은 리팩토링: 메인 에이전트가 직접 처리
   큰 리팩토링 (>5개 파일): /refactor-clean 사용
   → 레거시 코드 현대화
   → 죽은 코드 제거
   → 패턴 업데이트

2. test-writer 에이전트에 위임
   → 누락된 테스트 추가
   → 커버리지 확보
   → 엣지 케이스 테스트

3. 간단한 문서: 메인 에이전트가 직접 업데이트
   포괄적인 문서: doc-updater 에이전트에 위임
   → 코드와 문서 동기화
   → API 문서 업데이트
   → 예제 새로고침
```

**패턴 4: 빌드 → 수정 → 검증**

```
1. 메인 에이전트가 /build-fix 명령어 실행
   → 빌드 오류 자동 수정
   → 타입 오류 처리
   → import 수정

2. (복잡한 빌드 문제인 경우)
   devops-specialist 에이전트에 위임
   → 체계적인 오류 수정
   → 영향별 우선순위 지정

3. 메인 에이전트가 /checkpoint 실행
   → 종합적 검증
   → 모든 것이 작동하는지 확인
```

### 4.3 병렬 에이전트 패턴

**서브에이전트 시스템** (대부분의 작업에 권장):
메인 에이전트는 단일 메시지에서 여러 Task 도구 호출로 여러 전문가에게 병렬 위임할 수 있습니다:

```
메인 에이전트가 병렬로 위임:
- code-reviewer 에이전트 (코드 품질)
- test-writer 에이전트 (테스트 작성)
- doc-updater 에이전트 (문서 업데이트)

모든 결과가 메인 에이전트로 돌아와 검토됩니다
```

**에이전트 팀 시스템** (병렬 TDD용):
`/parallel-tdd` 명령어로 에이전트 팀을 생성합니다:

```
→ 스펙의 각 REQ를 별도의 팀원이 담당
→ 각 팀원이 워크트리에서 독립적으로 작업
→ 공유 태스크 리스트로 자체 조정
→ 직접 메시지로 서로 소통
```

**여러 세션** (큰 독립적인 작업을 위해):
필요한 경우 병렬 Claude Code 세션을 실행:

```
터미널 1 (메인): 메인 에이전트가 기능 A 구현
터미널 2: 메인 에이전트가 기능 B 구현
터미널 3: code-reviewer 에이전트에 위임 (포괄적 감사)
터미널 4: test-writer 에이전트에 위임 (전체 테스트 스위트 생성)
터미널 5: /checkpoint 실행 (지속적 검증)
```

**병렬 실행의 이점**:
- 더 빠른 전체 완료 (작업이 동시에 진행됨)
- 독립적인 컨텍스트 (작업 간 컨텍스트 오염 없음)
- 에이전트별 전문화된 집중 (각 에이전트가 자신의 도메인에서 작업)
- 더 나은 리소스 활용 (Claude 사용 극대화)

**병렬 실행을 사용해야 할 때**:
- 독립적인 측면이 있는 대규모 기능
- 여러 리뷰가 필요한 경우 (보안, 코드 품질, 성능) - 단일 세션 병렬 사용
- 백그라운드 문서 업데이트
- 지속적 테스트 생성
- 완전히 별도의 기능 - 여러 세션 사용

**한계**:
- 권장: 3-5개 병렬 세션 (여러 터미널을 사용하는 경우)
- 최대: 5개 세션 (이 이상은 수익 감소)
- 리뷰 작업의 경우 단일 세션 병렬 위임 선호

### 4.4 에이전트 컨텍스트 관리

**핵심 원칙**: 에이전트는 메인 세션과 분리된 격리된 컨텍스트를 가집니다

**위임 결정 매트릭스**:

| 작업 유형 | 처리자 | 이유 |
|-----------|--------|------|
| 컴포넌트 생성 | 메인 에이전트 | 표준 React 작업 |
| CRUD 엔드포인트 추가 | 메인 에이전트 | 표준 REST 패턴 |
| 오타/버그 수정 | 메인 에이전트 | 사소한 변경 |
| OAuth 통합 | auth-specialist | 복잡한 인증 프로토콜 |
| DB 마이그레이션 | backend-specialist | 위험 완화 필요 |
| 보안 감사 | code-reviewer | 전문가 검증 필요 |
| 성능 최적화 | frontend-specialist | 프로파일링 전문성 필요 |
| 대규모 리팩토링 (>5개 파일) | /refactor-clean | 체계적 접근 필요 |

**모범 사례**:

1. **명확한 목표 제공**
   ```
   나쁨: "auth 코드를 봐주세요"
   좋음: "JWT 처리에서 보안 취약점에 대해 src/auth/를 검토하세요"
   ```

2. **집중할 파일 지정**
   ```
   나쁨: "코드베이스를 리팩토링하세요"
   좋음: "리포지토리 패턴을 사용하도록 src/services/UserService.ts를 리팩토링하세요"
   ```

3. **에이전트 컨텍스트에 과부하 주지 마세요**
   ```
   나쁨: "src/의 50개 파일을 모두 읽고 분석하세요"
   좋음: "3개의 인증 파일을 분석하세요: auth.ts, jwt.ts, middleware.ts"
   ```

4. **메인 에이전트가 표준 작업 처리**
   ```
   → CRUD, 컴포넌트, 간단한 라우트: 메인 에이전트가 직접 코딩
   → 전문 도메인: 적절한 전문가에게 위임
   → 리뷰: 병렬로 위임 (보안, 코드 품질)
   ```

**컨텍스트 크기 가이드라인**:
- <3개 파일 및 표준 작업: 메인 에이전트가 직접 처리
- 3-10개 파일 및 전문 분야: 전문가에게 위임 고려
- >10개 파일 또는 복잡한 도메인: 적절한 전문가에게 위임

---

## 5. MCP 서버 통합

### 5.1 MCP 서버란?

Model Context Protocol(MCP) 서버는 외부 도구 통합을 제공합니다:

**사용 가능한 통합:**
- **filesystem**: 파일 작업 (항상 활성화, 필수)
- **slack**: 팀 커뮤니케이션 및 PR 알림 (**필수** - commit-업데이트 채널에 자동 알림)
- **github**: GitHub API 작업 (이슈, PR, 커밋)
- **postgres/sqlite**: 데이터베이스 쿼리 및 마이그레이션
- **vercel/railway**: 호스팅 플랫폼에 배포
- **memory**: Claude 세션 간 영구 메모리
- **sequential-thinking**: 복잡한 문제를 위한 향상된 추론
- **brave-search**: 웹 검색 기능
- **google-maps**: 위치 및 지도 서비스
- **firecrawl**: 웹 스크래핑 및 크롤링
- **cloudflare**: CDN, workers, 관찰 가능성
- **clickhouse**: 분석 데이터베이스 쿼리
- **context7**: 컨텍스트 관리 도구
- **magic**: 추가 유틸리티

**필수 MCP 서버:**
- **filesystem**: 항상 활성화됨 (파일 작업에 필요)
- **slack**: 설정 중 필수 구성 (commit-업데이트 채널에 PR 알림을 자동으로 보냄)

설정 마법사(`node setup.cjs`)를 실행하면 Slack MCP 자격 증명이 자동으로 요청됩니다:
- Slack Bot Token (https://api.slack.com/apps 에서 발급)
- Slack Team ID (T로 시작하는 ID)

### 5.2 MCP 서버 활성화

**1단계: 현재 구성 확인**

```bash
# 활성화된 MCP 확인
grep '"disabled": false' .mcp.json
```

**2단계: API 자격 증명 추가** (필요한 경우)

```bash
# .env 파일 또는 환경 변수에서
export GITHUB_PERSONAL_ACCESS_TOKEN="ghp_xxxxx"
export POSTGRES_URL="postgresql://localhost/mydb"
export VERCEL_API_TOKEN="your_token_here"
```

**3단계: .mcp.json에서 활성화**

```json
// 활성화할 서버 찾기
{
  "mcpServers": {
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "YOUR_GITHUB_TOKEN_HERE"
      },
      "disabled": false  // ← true에서 false로 변경
    }
  }
}
```

**4단계: Claude Code 세션 재시작**

MCP는 Claude Code가 시작될 때 로드됩니다. 변경 사항을 적용하려면 세션을 재시작하세요.

### 5.3 MCP 서버 사용 패턴

**GitHub 통합**:
```
활성화: github MCP 서버
용도:
→ 코드 TODO에서 이슈 생성
→ 풀 리퀘스트에 댓글 달기
→ 리포지토리 검색
→ 커밋 이력 가져오기
→ 프로젝트 보드 관리
```

**데이터베이스 통합**:
```
활성화: postgres 또는 sqlite MCP 서버
용도:
→ 데이터베이스에 직접 쿼리
→ 스키마 검사
→ 마이그레이션 생성
→ 테스트 데이터 설정
→ 성능 분석
```

**배포 통합**:
```
활성화: vercel 또는 railway MCP 서버
용도:
→ 프로덕션에 배포
→ 배포 상태 확인
→ 배포 로그 보기
→ 잘못된 배포 롤백
→ 환경 변수 관리
```

**Slack 통합** (필수):
```
활성화: slack MCP 서버 (필수)
용도:
→ PR 생성 시 commit-업데이트 채널에 자동 알림
→ 코드 푸시 시 commit-업데이트 채널에 자동 알림
→ PR 제목, 설명, 링크를 포함한 전체 알림
→ 팀원들이 GitHub를 열지 않고도 모든 세부 정보 확인 가능
→ 코딩을 모르는 팀원도 이해할 수 있는 자연스러운 한국어로 작성
→ 팀 커뮤니케이션 및 알림

중요: 이 템플릿은 /commit-push-pr 명령어를 사용할 때 자동으로
commit-업데이트 채널에 자연스러운 전문 한국어로 번역된 PR 설명과
함께 Slack 메시지를 보냅니다. 비개발자 팀원들도 쉽게 이해할 수
있도록 설계되었습니다.
```

**검색 통합**:
```
활성화: brave-search MCP 서버
용도:
→ 문서 조사
→ 코드 예제 찾기
→ API 참조 확인
→ 새 라이브러리 학습
```

### 5.4 MCP를 통한 컨텍스트 관리

**중요 경고**: 너무 많은 활성화된 MCP는 성능을 심각하게 저하시킵니다.

**200k → 70k 문제**:
- 시작 컨텍스트 윈도우: 200k 토큰
- 10개 MCP + 20개 도구 활성화 시: 약 70k로 감소
- 결과: 느린 응답 (>10초), 불완전한 답변, 세션 충돌

**성능 가이드라인**:

```bash
# 활성화된 MCP 개수 확인
grep '"disabled": false' .mcp.json | wc -l

# 최적 성능을 위해 10개 미만이어야 함
```

**프로젝트별 비활성화**:

```json
// .claude/settings.local.json
{
  "disabledMcpServers": [
    "slack",           // 이 프로젝트에서 Slack 미사용
    "google-maps",     // 지도 미사용
    "cloudflare-docs"  // Cloudflare에 배포하지 않음
  ]
}
```

**모범 사례**:
- 적극적으로 사용하는 MCP만 활성화
- 통합 사용이 끝나면 MCP 비활성화
- 총 활성화 개수를 10개 미만으로 유지
- 응답 시간 모니터링 (>5초 = MCP가 너무 많음)

---

## 6. 성능 및 최적화

### 6.1 컨텍스트 윈도우 관리

전체 세부사항은 `.claude/rules/essential-rules.md`를 참조하세요.

**하드 리미트** (실전 테스트된 임계값):
- **활성화된 MCP**: 프로젝트당 10개 미만
- **활성 도구**: 총 80개 미만
- **세션당 읽은 파일**: 50개 미만
- **목표 컨텍스트 사용량**: 60-80k 토큰 (>120k는 안 됨)

**성능 경고 신호**:
- 응답 시간 >10초
- 불완전한 응답 또는 중간에 끊김
- Claude가 "간략하게 해야 합니다"라고 말함
- 세션 충돌 또는 타임아웃

**최적화 전략**:

1. **사용하지 않는 MCP 비활성화**
   ```bash
   # 개수 확인
   grep '"disabled": false' .mcp.json | wc -l

   # 사용하지 않으면 비활성화
   # .mcp.json을 편집하고 "disabled": true로 설정
   ```

2. **무거운 작업을 에이전트에 위임**
   ```
   나쁨: 메인 컨텍스트에서 50개 파일 읽기
   좋음: 격리된 컨텍스트를 가진 에이전트에 위임
   ```

3. **규칙/스킬을 간결하게 유지**
   ```
   규칙: 각각 500줄 미만
   스킬: 각각 800줄 미만
   오래된 콘텐츠 제거
   ```

4. **정기적으로 새 세션 시작**
   ```
   컨텍스트가 무거워질 때 (느린 응답):
   → 작업 저장
   → 새 Claude Code 세션 시작
   → 새로운 컨텍스트로 계속
   ```

### 6.2 모델 선택 전략

**Haiku** ($) - 빠르고 저렴함:
- 코드 포맷팅 (Prettier, ESLint)
- 간단한 한 줄 수정
- 테스트 실행
- 빠른 리팩토링 (<10줄)
- 반복 작업

**Sonnet** ($$) - 균형 잡힘 (기본값):
- 기능 구현
- 버그 수정
- 코드 리뷰
- 테스트 작성
- 대부분의 개발 작업
- 일반 리팩토링

**Opus** ($$$) - 강력하고 비쌈:
- 복잡한 아키텍처 설계
- 중요한 보안 결정
- 프로덕션 인시던트 대응
- 대규모 리팩토링 (>500줄)
- 시스템 설계 논의

**모델 전환**:

```json
// .claude/settings.json에서
{
  "model": "haiku"   // 또는 "sonnet" 또는 "opus"
}
```

**비용-편익 분석**:
- Haiku: 빠르지만 더 많은 왕복이 필요할 수 있음
- Sonnet: 균형 잡힘, 90%의 작업에 적합
- Opus: 느리지만 복잡한 작업에서 첫 번째 시도에 올바름

### 6.3 병렬 세션

더 빠른 완료를 위해 여러 Claude Code 세션을 동시에 실행:

**설정**:
```
터미널/VSCode 창 1: 메인 개발 작업
터미널/VSCode 창 2: code-reviewer 에이전트에 위임 (보안 및 코드 품질 감사)
터미널/VSCode 창 3: test-writer 에이전트에 위임 (테스트 생성)
터미널/VSCode 창 4: doc-updater 에이전트에 위임 (문서화)
터미널/VSCode 창 5: /checkpoint 실행 (지속적 검증)
```

**이점**:
- 각 세션이 전체 200k 컨텍스트 윈도우를 가짐
- 세션 간 컨텍스트 오염 없음
- 더 빠른 전체 완료 (병렬 작업)
- 더 나은 집중 (각 세션이 하나의 작업을 수행)

**권장 한계**:
- 2-3개 세션으로 시작
- 대규모 기능의 경우 최대 5개 세션으로 확장
- 5개 세션 이상: 수익 감소

---

## 7. 커스터마이제이션 로드맵

### 7.1 1주차: 필수 설정

**1-2일차: 초기 구성**

```
1일차:
- [ ] README.md와 CLAUDE.md 읽기
- [ ] git 리포지토리 초기화
- [ ] 첫 명령어 실행: /checkpoint
- [ ] 사용 가능한 명령어 탐색 (/help)

2일차:
- [ ] 플랜 모드 시도 (Shift+Tab 두 번)
- [ ] /commit-push-pr 워크플로우 테스트
- [ ] GitHub 사용 시 github MCP 활성화
```

**3-4일차: CLAUDE.md 커스터마이즈**

```
3일차:
- [ ] CLAUDE.md에 기술 스택 문서화
- [ ] 팀 명명 규칙 추가
- [ ] 프로젝트 의존성 나열

4일차:
- [ ] CLAUDE.md에 첫 번째 일반적인 실수 문서화
- [ ] 프로젝트별 패턴 추가
- [ ] 코드 리뷰 체크리스트 설정
```

**5-7일차: 필수 MCP 활성화**

```
5일차:
- [ ] 데이터베이스 MCP 활성화 (postgres 또는 sqlite)
- [ ] 데이터베이스 쿼리 테스트

6일차:
- [ ] 배포 MCP 활성화 (vercel 또는 railway)
- [ ] 배포 워크플로우 테스트

7일차:
- [ ] 활성화된 MCP 검토 (10개 미만이어야 함)
- [ ] 통합이 올바르게 작동하는지 테스트
```

### 7.2 첫 달: 파워 유저

**2주차: 명령어 마스터**

```
- [ ] 25개 명령어 중 핵심 명령어를 최소 한 번 사용
- [ ] 여러 명령어를 결합한 워크플로우 생성
- [ ] 프로젝트에 대한 사전 승인 작업 설정
- [ ] 워크플로우에 맞게 훅 커스터마이즈
```

**3주차: 에이전트 숙달**

```
- [ ] 각 에이전트 유형에 위임
- [ ] 순차적 에이전트 워크플로우 생성 (설계 → 구현 → 리뷰 → 검증)
- [ ] 병렬 에이전트 세션 시도 (2-3개 터미널)
- [ ] 에이전트 사용 대 직접 구현 시기 이해
```

**4주차: 품질 자동화**

```
- [ ] 프리 커밋 훅 설정
- [ ] 환경별 설정 구성 (개발/운영)
- [ ] CI/CD 파이프라인과 통합
- [ ] 팀 코드 리뷰 워크플로우 확립
```

### 7.3 지속적: 복합적 개선

**월간 작업**:
```
- [ ] CLAUDE.md 검토 및 업데이트
- [ ] 새로 발견된 실수 추가
- [ ] 코드베이스가 발전함에 따라 패턴 업데이트
- [ ] 팀과 개선 사항 공유
- [ ] 활성화된 MCP 검토 및 최적화
```

**분기별 작업**:
```
- [ ] 반복 작업을 위한 커스텀 에이전트 생성
- [ ] 팀 워크플로우를 위한 커스텀 명령어 구축
- [ ] 추가할 새 MCP 평가
- [ ] 유용한 패턴을 커뮤니티에 기여 (선택 사항)
```

### 7.4 커스텀 명령어 만들기

**템플릿**:

```markdown
# 내 커스텀 명령어

[이 명령어가 수행하는 작업에 대한 한 줄 설명]

## 사용법

이 명령어를 언제 사용하고 무엇을 달성하는지.

## 지침

1. Claude가 따를 단계별 지침
2. 구체적이고 실행 가능하게
3. 오류 처리 포함
4. 필요에 따라 스킬/규칙 참조

## 예제

입력과 예상 출력을 보여주는 구체적인 사용 예제.
```

**저장 위치**: `.claude/commands/my-command.md`

### 7.5 커스텀 에이전트 만들기

**템플릿**:

```markdown
# 내 커스텀 에이전트

[에이전트의 전문 분야에 대한 한 줄 설명]

## 전제 조건

- [필요한 도구 또는 설정]
- [필요한 의존성]

## 지침

이 전문 작업에 대한 상세한 단계별 지침.
포함 사항:
- 분석할 내용
- 찾아야 할 내용
- 보고할 내용
- 사용할 형식

## 사용 예제

"[특정 작업]을 위해 my-agent 에이전트에 위임"

예상 출력 형식 및 결과.
```

**저장 위치**: `.claude/agents/my-agent.md`

---

## 8. 팀 협업

### 8.1 공유 CLAUDE.md

**모범 사례**: 프로젝트당 하나의 CLAUDE.md, 버전 관리에 커밋됨

**구조**:

```markdown
## 목적
이 파일이 존재하는 이유와 사용 방법

## 기술 스택
버전이 포함된 완전한 기술 스택

## 일반적인 실수
시간이 지남에 따라 발견된 팀별 주의사항
- 실수가 발생할 때마다 이 섹션에 추가
- 무엇이 잘못되었고 올바른 접근 방식은 무엇인지 포함

## 프로젝트별 패턴
이 프로젝트에 특정한 패턴
- API 응답 형식
- 오류 처리 접근 방식
- 데이터베이스 접근 패턴
- 인증 플로우
```

**업데이트 빈도**: 모든 실수나 배운 교훈 후

**팀 워크플로우**:
```
1. 개발자가 실수를 함
2. 실수를 수정함
3. CLAUDE.md에 문서화함
4. CLAUDE.md 업데이트를 커밋함
5. 팀이 공유 지식으로부터 혜택을 받음
```

### 8.2 코드 리뷰 통합

**리뷰어의 워크플로우**:

```
1. 리뷰할 브랜치 가져오기
2. Claude에게 요청: "이 PR 리뷰: [PR URL 또는 설명]"
3. Claude 분석:
   → 변경된 모든 파일
   → 프로젝트 규칙에 대한 검사
   → 테스트 커버리지 확인
   → 잠재적 문제 식별
4. Claude의 발견 사항 검토
5. 자신의 관찰 추가
6. PR 작성자에게 피드백 제공
```

**PR 제출 전** (작성자):

```
/review               # 코드 품질 리뷰
/checkpoint           # 타입, 린트, 테스트, 빌드, 보안 검증

그다음:
/commit-push-pr       # PR 생성
```

### 8.3 TODO 주석을 통한 비동기 협업

**패턴**: 팀원(또는 미래의 자신)을 위한 TODO 주석 남기기

```typescript
// TODO(@teammate): 이것은 엣지 케이스 X에 대한 오류 처리가 필요합니다
// 우리의 표준 접근 방식은 CLAUDE.md의 오류 패턴 섹션을 참조하세요

// TODO(@me): API가 안정화되면 이것을 리팩토링하세요
// 현재 3가지 다른 응답 형식을 처리 중

// TODO: 여기에 속도 제한을 추가하세요
// 우리의 속도 제한 패턴은 security.md 규칙을 참조하세요
```

Claude Code는:
- TODO 주석 탐지
- 이에 대해 상기시킴
- 요청 시 해결 지원
- CLAUDE.md 패턴을 기반으로 구현 제안

---

## 9. 문제 해결

### 9.1 일반적인 문제

**문제: "응답이 느림 (>10초)"**

**진단**: 너무 많은 활성화된 MCP 또는 비대해진 컨텍스트

**해결책**:
```bash
# 활성화된 MCP 확인
grep '"disabled": false' .mcp.json | wc -l

# 10개 미만이어야 함
# 더 많으면 .mcp.json을 편집하여 사용하지 않는 것들을 비활성화
```

**문제: "에이전트가 예상대로 작동하지 않음"**

**진단**: 불명확한 위임 또는 잘못된 에이전트 선택

**해결책**:
```
나쁨: "code-reviewer를 사용하세요"
좋음: "src/auth/ 디렉토리의 JWT 처리를 보안 리뷰하기 위해 code-reviewer 에이전트에 위임하세요"

나쁨: "에이전트가 이것을 봐주세요"
좋음: "인증 플로우에서 OWASP Top 10 취약점을 스캔하기 위해 code-reviewer 에이전트에 위임하세요"
```

**문제: "명령어를 찾을 수 없음"**

**진단**: 명령어 파일이 누락되었거나 잘못 명명됨

**해결책**:
```bash
# 명령어가 존재하는지 확인
ls .claude/commands/

# 명명 규칙 확인:
# 명령어: /checkpoint
# 파일: checkpoint.md (정확히 일치)
```

**문제: "훅이 작업을 차단함"**

**진단**: 훅이 너무 오래 걸리거나 실패함

**해결책**:
```bash
# 일시적으로 훅 비활성화
# .claude/settings.json 편집
{
  "hooks": []  // 빈 배열은 모든 훅을 비활성화함
}

# 또는 특정 훅 수정:
# 훅은 100ms 미만에 완료되어야 함
# 차단 방지를 위해 || true 추가:
"command": "your-command || true"
```

**문제: "MCP 서버가 연결되지 않음"**

**진단**: 비활성화됨, 자격 증명 누락 또는 네트워크 문제

**해결책**:
```bash
# 1. 활성화 확인
# .mcp.json에서: "disabled": false

# 2. 자격 증명 확인
# 환경 변수가 올바르게 설정되었는지 확인

# 3. MCP를 직접 테스트
npx @modelcontextprotocol/server-github

# 4. 네트워크 확인
# 일부 MCP는 인터넷 액세스 필요

# 5. Claude Code 재시작
# MCP는 세션 시작 시 로드됨
```

### 9.2 도움 받기

**셀프 서비스**:
1. 이 가이드 확인
2. [README.md](README.md) 검토
3. `.claude/rules/`의 관련 규칙 파일 읽기
4. 프로젝트별 안내는 CLAUDE.md 검색
5. `.claude/skills/`의 스킬 파일 확인
6. `.claude/agents/INDEX.md`의 에이전트 인덱스 확인

**커뮤니티 지원**:
1. 기존 GitHub 이슈 검색
2. 다음을 포함한 새 이슈 열기:
   - 문제에 대한 명확한 설명
   - 재현 단계
   - 예상 대 실제 동작
   - 환경 세부 정보 (OS, Claude Code 버전)

---

## 10. 고급 주제

### 10.1 훅 커스터마이제이션

`.claude/settings.json`에서 훅을 구성하세요 - `hooks` 섹션을 참조하세요.

**프리 툴 훅** (작업 전 경고):

```json
{
  "when": "PreToolUse",
  "matcher": "tool == \"Write\" && tool_input.file_path matches \"\\\\.tsx?$\"",
  "hooks": [{
    "type": "command",
    "command": "grep -n 'console\\.log' \"$file_path\" 2>/dev/null && echo '[Hook] 경고: console.log 탐지됨' >&2 || true"
  }]
}
```

**포스트 툴 훅** (작업 후 자동 포맷팅):

```json
{
  "when": "PostToolUse",
  "matcher": "tool in [\"Edit\", \"Write\"] && tool_input.file_path matches \"\\\\.tsx?$\"",
  "hooks": [{
    "type": "command",
    "command": "npx prettier --write \"$file_path\" 2>&1 | head -1"
  }]
}
```

**성능 요구사항**: 훅은 100ms 미만에 완료되어야 합니다

### 10.2 환경별 워크플로우

**개발** (`settings.dev.json`):
- Sonnet 모델 (더 빠르고 저렴함)
- 자동 수락 활성화 (안전성보다 속도)
- 모든 작업 허용 (최대 자유)
- 허용적 훅

**프로덕션** (`settings.prod.json`):
- Opus 모델 (최고 품질)
- 자동 수락 비활성화 (안전 우선)
- 읽기 전용 작업만 (실수로 변경하지 않음)
- 엄격한 훅

**환경 전환**:

```bash
# 개발로 전환
cp .claude/settings.dev.json .claude/settings.json

# 프로덕션으로 전환
cp .claude/settings.prod.json .claude/settings.json
```

### 10.3 사전 승인된 작업

사용자 확인이 필요 없는 작업 구성:

```json
{
  "allowedPrompts": [
    {"tool": "Bash", "prompt": "run tests"},
    {"tool": "Bash", "prompt": "run build"},
    {"tool": "Bash", "prompt": "format code"},
    {"tool": "Bash", "prompt": "run linter"},
    {"tool": "Bash", "prompt": "install dependencies"}
  ]
}
```

**이점**:
- 더 빠른 워크플로우 (권한 프롬프트 없음)
- 더 적은 중단 (자동 승인)
- 더 나은 자동화 (지속적 작업)

**보안 고려사항**:
- 읽기 전용 및 안전한 작업만 사전 승인
- 사전 승인하지 않을 것: 파괴적 작업, 배포, 데이터베이스 쓰기
- 코드베이스가 발전함에 따라 정기적으로 검토

---

## 빠른 참조

### 가장 많이 사용하는 명령어 (매일)

```bash
/plan                # 스펙 기반 계획 수립
/tdd                 # 스펙 기반 TDD 개발
/checkpoint          # 통합 검증 게이트
/commit-push-pr      # 커밋 생성, 푸시 및 PR
/quick-fix           # 빠른 버그 수정
/open-localhost      # 개발 서버를 브라우저에서 열기 (포트 자동 감지)
```

### 가장 많이 사용하는 에이전트 (매주)

```bash
architect            # 시스템 설계 및 계획
code-reviewer        # PR 리뷰, 보안, 코드 품질
test-writer          # TDD, 테스트 전략
backend-specialist   # REST API, DB, 마이그레이션
auth-specialist      # OAuth, JWT, MFA
```

### 가장 중요한 규칙

```bash
essential-rules.md   # 보안, 테스트, 코딩 표준 (통합됨)
orchestration.md     # 위임, 워크플로우, git 표준
task-protocol.md     # 에이전트 실행 프로토콜
```

### 중요한 성능 임계값

```
활성화된 MCP: 10개 미만
활성 도구: 80개 미만
읽은 파일: 세션당 50개 미만
응답 시간: 5초 미만 (>5초 시 경고)
컨텍스트 사용량: 60-80k 목표 (>120k 시 경고)
```

---

## 다음 단계

**신규 사용자**: 프로젝트 개요는 [README.md](README.md)로 시작하세요

**시작하기**: [1주차: 필수 설정](#71-1주차-필수-설정)을 따르세요

**팀 리더**: [팀 협업](#8-팀-협업) 섹션을 읽으세요

**파워 유저**: [고급 주제](#10-고급-주제)를 탐색하고 커스텀 명령어/에이전트를 만드세요

**도움이 필요하신가요?**: [문제 해결](#9-문제-해결)을 확인하거나 이슈를 여세요

---

## 추가 리소스

- **프로젝트 개요**: [README.md](README.md)
- **팀 가이드라인**: [CLAUDE.md](CLAUDE.md)
- **에이전트 디렉토리**: [.claude/agents/INDEX.md](.claude/agents/INDEX.md)
- **스킬 디렉토리**: [.claude/skills/INDEX.md](.claude/skills/INDEX.md)
- **명령어 가이드**: [.claude/commands/README.md](.claude/commands/README.md)
- **체크리스트**: [.claude/checklists/README.md](.claude/checklists/README.md)
- **템플릿**: [.claude/templates/README.md](.claude/templates/README.md)
- **워크플로우**: [.claude/workflows/README.md](.claude/workflows/README.md)

---

**기억하세요**: 이것은 복합적인 시스템입니다. CLAUDE.md에 문서화하는 모든 실수, 추가하는 모든 패턴, 만드는 모든 명령어 - 이 모든 것이 팀을 더 빠르게 하고 코드를 더 좋게 만듭니다. 작게 시작하여 꾸준히 성장하면 생산성이 배가되는 것을 보게 될 것입니다.

**질문이 있으신가요?** 팀도 혜택을 받을 수 있도록 CLAUDE.md에 답변을 업데이트하세요.
